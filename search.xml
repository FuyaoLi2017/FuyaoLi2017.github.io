<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How to Override DAO Create and Update using flow]]></title>
    <url>%2F2019%2F05%2F29%2Foverride-DAO%2F</url>
    <content type="text"><![CDATA[Today I meet a task, which requires me to migrate some hooks to DAO. In DAO itself, some operations are different. I also have a deeper understanding of the three dot sign in JavaScript. Code12345678910111213141516 export class ClassroomDAO extends DAO&lt;Classroom&gt; &#123; constructor(context) &#123; super('Classroom', context) &#125; async create(input: Classroom) &#123; const checkedClassroom = checkValidDays(input) return super.create(checkedClassroom) &#125; async update(id: string, input: $Shape&lt;Classroom&gt;) &#123; const classroom = await super.get(id) // directly use get checkValidDays(&#123; ...classroom, ...input &#125;) return super.update(id, input) &#125;&#125; The Code above is the the way to override ClassroomDAO functions. Defining functions with the same name from the DAO it extends will override it’s previous function. $Shape&lt;Classroom&gt; is a syntax used in Flow. It can hold part of the fields in a Model object. Even if a fields is required, it can still choose not to hold it. https://medium.com/netscape/secret-flow-types-86b2ebb30951 checkValidDays({ ...classroom, ...input }) For this part, use three dot to destructure the classroom thing fetched(the whole object) and use the new fields in input to override part of the fields in classroom. In this way, checkValidDays function will check the expected updated result of the new classroom thing, though it is a temporary variable. The final update will be done in return super.update(id, input). checkValidDays will mainly check whether the input classroom is valid or not, if not, it will throw an error. Otherwise, it won’t do anything.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
        <tag>flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to write standard GraphQL mutations]]></title>
    <url>%2F2019%2F05%2F17%2Fhow-to-write-graphQL-mutation%2F</url>
    <content type="text"><![CDATA[Basic steps of building a mutation in graphQL define the return value strcture.(useful error message report and status feedback). Define the mutation resolve function Define the input parameters and output parameters of the mutation. export the queries and mutations in this file and register it in index.js An example of writing a mutation More detailed source code can be referred right here(Private Repo). The code here is modified to avoid showing the business logic.https://github.com/FuyaoLi2017/JavaScript-Learning/blob/master/building-mutation-in-graphql.md 1. Step1: Define the return value I have changed the code to blur the original business logic. Main idea is to show the syntax. This is suppose to support a service to update all student grade according to centain rules. comma(,) is used to separate different properties within an object, normal JS sentences are separated by line feed, or semi colon;. You need to import corresponding graphQL type if that thing exists in your code. When we try to create the return data structure, we need to give feedback information as much as possible to help the frontend to locate the problem. Giving fields like success, warning,message, useful wrong output lists are helpful. Pay attention to the indentation of the oneLine thing. Just one TAB behind curly braces! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123; oneLine &#125; from 'common-tags'import &#123; r &#125; from '../../services/thinky'import &#123; GraphQLObjectType, GraphQLNonNull, GraphQLBoolean, GraphQLString, GraphQLList, GraphQLID,&#125; from '../scalars'const SubField = new GraphQLObjectType(&#123; name: 'subField', fields: () =&gt; (&#123; studentID: &#123; type: new GraphQLNonNull(GraphQLID), description: oneLine` XXX `, &#125;, failedReason: &#123; type: new GraphQLNonNull(GraphQLString), description: 'XXX', &#125;, &#125;),&#125;)const Result = new GraphQLObjectType(&#123; name: 'Result', fields: () =&gt; (&#123; success: &#123; type: new GraphQLNonNull(GraphQLBoolean), &#125;, warning: &#123; type: new GraphQLNonNull(GraphQLBoolean), &#125;, message: &#123; type: new GraphQLNonNull(GraphQLString), description: oneLine` XXX `, &#125;, failedStudentsList: &#123; type: new GraphQLList(SubField), description: oneLine` XXX `, &#125;, &#125;),&#125;) Step2: Use async function to update the information in the database If we fetch something, even if it don’t have any return sentence, it won’t be null. The length will be 0, We should check student.length == 0 instead of !student. Different between for ___ of ___ and for ___ in ___ for ... in ... iterate over the keys of the objects. For array, it should be the index, 0,1,2,3… for ... of ... iterate the values of the objects directly. so the following codes are the same12345678for (a in stuff) &#123; value = stuff[a] console.log(value)&#125;for (value of stuff) &#123; console.log(value)&#125; [] is used destructure an array, this let you to separate variables.123456789const [a, b, c] = [1, 2, 3] // then, the value of a, b, c will be a = 1 b = 2 c = 3 // if you don't want all parameters const [a, b] = [1, 2, 3] a = 1 b = 2 Also, you can use ... to hold the rest of variables in an array. https://dev.to/sagar/three-dots---in-javascript-26ci Several ways to append elements at the end of the array123456789arr = ["a", "b", "c"]// (1)using pusharr.push("d")// (2) using concatarr.concat(["d", "e", "f"])// (3) using the lengtharr.[arr.length] = "d" In the naming convention the GraphQL type, the first letter should be capitalized. For await function, we don’t need to handle the exceptions, it will handle itself in our base classes. Some fields of a certain graphQL type is not contained in its DAO, it is connected by its ID. We should use other DAO to fetch the things we want. Just check the rethinkdb database when the graphQL schema is not so clear. Database will have all fields we are looking for. Backtick usageWhen we need to console.log() something, quote mark will work, but we can add any other extra variables.with backtick, we can add extra variables. Also, oneLine node module can used right here to format the back tick surrounded strings.https://stackoverflow.com/questions/27678052/usage-of-the-backtick-character-in-javascript different between undefined and null.undefined means the object don’t have such a field.null means the object has such field but it is null, if you add 1 to null, it will become 1. Super weird!!! 123// exampleconsole.log(`a is: $&#123;a&#125;`)console.log(`PI is nearly $&#123;Math.max(a, b)&#125;`) 1234567891011121314151617181920212223242526272829const updateGradeLevelResolve = async context =&gt; &#123; const &#123; studentDAO, familyAccountDAO &#125; = context.dao const students = await studentDAO.fetch() if (students.length == 0) &#123; return &#123; success: false, message: 'xxx', &#125; &#125; /*MAIN BUSINESS LOGIC*/ let message = 'Finish updating all students grade.' let warning = false if (failedStudentsList.length &gt; 0) &#123; message = oneLine` Finished updating student grades, but couldn't update some. See the failedStudentsList for more information. ` warning = true &#125; return &#123; success: true, warning, message, failedStudentsList, &#125;&#125; Step3: resolve the mutation In this example, there is no input arguments. If there is, we should define and pass args in the resolve function.123456789101112131415const updateGradeLevel = &#123; type: UpdateGradeLevelResult, description: oneLine` This mutation will run once a year in June before summer camp starts. All student grade level will advance one year. If the grade level is between 0 - 11, add 1 to the grade level. If the grade level is 12, this mutation will add 1 to the grade level and change EnrollmentStatus to GRADUATED. If the family has another students under grade 12. the mutation will do nothing. Otherwise, change student.familyAccount.status to CLOSED. `, resolve(obj, args, context) &#123; return updateGradeLevelResolve(context) &#125;,&#125; Step4 export the mutations and queries export in the local file.12export const queries = &#123;&#125;export const mutations = &#123; updateGradeLevel &#125; import and export in the index.js file to expose a more standard naming of the files.123456789101112import &#123; queries as updateGradeLevelQs, mutations as updateGradeLevelMs,&#125; from './updateGradeLevel'export const queries = &#123; ...updateGradeLevelQs,&#125;export const mutations = &#123; ...updateGradeLevelMs,&#125;]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
        <tag>mutation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how-to-write-hook-based-on-graphql]]></title>
    <url>%2F2019%2F05%2F17%2Fhow-to-write-hook-based-on-graphql%2F</url>
    <content type="text"><![CDATA[General Pratice to write a hook Define hooks in the hooks fields(the base methods are inplemented in base classes.) write async functions to update the hooks Purpose of writing hooks when we define a schema in types, it is not always enough, sometimes we need to automatically increment some values or do somethings after or before we insert some records into the database. With the light weight hooks. We can realize such kind of functionalities. Classfication of hooks general types create update archive happening time for every general type of hooks before after Example hook of updatingStep1: declare a update after hook12345hooks: &#123; update: &#123; after: updatePostFavorite, &#125;, &#125;, Step2: write function to implement In the base class, update hook have three parameters and they matches the three parameters in updatePostFavorite function. Therefore, there is no need to explicitly declare there are three variables in update hook above. use context.dao to update right information Notice that! With the same variable name favoriteCount, it can directly update the field favoriteCount in the post model. This is a feature of JS! I don’t the exact name of the this feature, maybe pass by value.123456789export async function updatePostFavorite(newFavorite, oldFavorite, context) &#123; if (newFavorite.favorited === oldFavorite.favorited) &#123; return &#125; const &#123; postFavoriteDAO, postDAO &#125; = context.dao const post = await postDAO.get(newFavorite.postId) const favoriteCount = post.favoriteCount + newFavorite.favorited ? 1 : -1 await postDAO.update(newFavorite.postId, &#123; favoriteCount &#125;)&#125;]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove duplicate elements from array or linkedlist]]></title>
    <url>%2F2019%2F05%2F14%2Fremove-duplicate-from-array-or-linkedlist%2F</url>
    <content type="text"><![CDATA[The Key idea of remove duplicate is two pointers. 1. Remove Duplicates from Sorted Array https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125;&#125; 2. Remove Duplicates from Sorted Array II https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ 12345678910111213141516171819202122232425// my solutionclass Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums.length &lt;= 2) &#123; return nums.length; &#125; int previous = nums[0]; int currentCount = 1; int end = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == previous &amp;&amp; currentCount &lt; 2) &#123; currentCount++; nums[end++] = nums[i]; &#125; else if (nums[i] == previous &amp;&amp; currentCount &gt;= 2) &#123; continue; &#125; else &#123; currentCount = 1; nums[end++] = nums[i]; previous = nums[i]; &#125; &#125; return end; &#125;&#125; // a more concise solution// remove duplicates from a sorted array12345678910111213141516public int removeDuplicates(int[] nums) &#123; int i = 0; for(int n : nums) if(i &lt; 1 || n &gt; nums[i - 1]) nums[i++] = n; return i;&#125;// Remove Duplicates from Sorted Array II (allow duplicates up to 2):public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i &lt; 2 || n &gt; nums[i - 2]) nums[i++] = n; return i;&#125; 3. Remove Duplicates from Sorted List https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */// iterative public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list != null) &#123; if (list.next == null) &#123; break; &#125; if (list.val == list.next.val) &#123; list.next = list.next.next; &#125; else &#123; list = list.next; &#125; &#125; return head; &#125;// recursivepublic ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null)return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head;&#125; 4. Remove Duplicates from Sorted List II https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; ListNode cur = head; while (cur != null) &#123; // use a while loop to skip all same values for current while (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; cur = cur.next; &#125; // there is only one element without duplicate, // the code didn't enter the while loop above // can move pre to pre.next if (prev.next == cur) &#123; prev = prev.next; &#125; // else, point the NEXT!! pointer of pre to cur.next else &#123; prev.next = cur.next; &#125; // advance the cur pointer after each operation cur = cur.next; &#125; return dummy.next; &#125; &#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>algorithm</tag>
        <tag>array</tag>
        <tag>linkedlist</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[backtracking]]></title>
    <url>%2F2019%2F05%2F11%2Fbacktracking%2F</url>
    <content type="text"><![CDATA[1. SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets. Solution1 use layer by layer DFS 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) return result; dfs(result, new ArrayList&lt;&gt;(), nums, 0); return result; &#125; public void dfs(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int[] nums, int index) &#123; if (index == nums.length) &#123; result.add(new ArrayList&lt;&gt;(current)); return; &#125; current.add(nums[index]); dfs(result, current, nums, index + 1); current.remove(current.size() - 1); dfs(result, current, nums, index + 1); &#125;&#125; use for loop to traverse in DFS 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 2. Subsets23. Combinations https://leetcode.com/problems/combinations/ Given two integers n and k, return all possible combinations of k numbers out of 1 … n.Input: n = 4, k = 2Output:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]] a better solution, using the input variable as counter, high vote answer 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; combs = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(combs, new ArrayList&lt;Integer&gt;(), 1, n, k); return combs; &#125; public static void combine(List&lt;List&lt;Integer&gt;&gt; combs, List&lt;Integer&gt; comb, int start, int n, int k) &#123; if(k==0) &#123; combs.add(new ArrayList&lt;Integer&gt;(comb)); return; &#125; for(int i=start;i&lt;=n;i++) &#123; comb.add(i); combine(combs, comb, i+1, n, k-1); comb.remove(comb.size()-1); &#125; &#125; My solution, using for loop to DFS 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (n &lt; k || k == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(result, new ArrayList&lt;&gt;(), 1, n, k); return result; &#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; currentList, int index, int n, int k) &#123; if (currentList.size() == k) &#123; result.add(new ArrayList&lt;&gt;(currentList)); return; &#125; if (index == n+1) &#123; // have reach the end of the array and has not accumlated to k elements return; &#125; for (int i = index; i &lt;= n; i++) &#123; currentList.add(i); dfs(result, currentList, i + 1, n, k); currentList.remove(currentList.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 975 - Odd Even Jump]]></title>
    <url>%2F2019%2F05%2F11%2Fleetcode-975%2F</url>
    <content type="text"><![CDATA[You are given an integer array A. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, …) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, …) jumps in the series are called even numbered jumps. You may from index i jump forward to index j (with i &lt; j) in the following way: During odd numbered jumps (ie. jumps 1, 3, 5, …), you jump to the index j such that A[i] &lt;= A[j] and A[j] is the smallest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j. During even numbered jumps (ie. jumps 2, 4, 6, …), you jump to the index j such that A[i] &gt;= A[j] and A[j] is the largest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j.(It may be the case that for some index i, there are no legal jumps.) A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.) Return the number of good starting indexes. ###Problem link: https://leetcode.com/problems/odd-even-jump/ 1. First Solution: TreeMap + DP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int oddEvenJumps(int[] A) &#123; int N = A.length; if (N &lt;= 1) return N; // the true/false value means the that position in A can be reached in a odd/even jump boolean[] odd = new boolean[N]; boolean[] even = new boolean[N]; odd[N - 1] = even[N - 1] = true; TreeMap&lt;Integer, Integer&gt; vals = new TreeMap&lt;&gt;(); // put the last element into the map vals.put(A[N - 1], N - 1); for (int i = N - 2; i &gt;= 0; --i) &#123; // get the current number in the given array int v = A[i]; // first check the map if it has already have the same number // with same number, it can be reached directly with odd/even jump if (vals.containsKey(v)) &#123; odd[i] = even[vals.get(v)]; even[i] = odd[vals.get(v)]; &#125; else &#123; // if the map don't have such key //we can find a key a strictly lower/higher than the new value Integer lower = vals.lowerKey(v); Integer higher = vals.higherKey(v); // for even jump, previous value should be larger, // the value in the map(number with larger index) should be smaller // so the even[i] will be placed with the value in odd[vals.get(lower)] if (lower != null) &#123; even[i] = odd[vals.get(lower)]; &#125; // for odd jump, previous value should be smaller, // the value in the map(number with larger index) should be larger // so the odd[i] will be placed with the value in even[vals.get(higher)] if (higher != null) &#123; odd[i] = even[vals.get(higher)]; &#125; &#125; // put the value into the map after all check vals.put(v, i); &#125; int ans = 0; for (boolean b: odd) if (b) ans++; return ans; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Check In]]></title>
    <url>%2F2019%2F05%2F09%2Fleetcode-everyday%2F</url>
    <content type="text"><![CDATA[Check in Leetcode submissionsToday is May 9th, start from today, I will solve at least two leetcode questions every day and mark in right here. All submission will be uploaded to my Github repo.!leetcode submission repo link For important questions and algorithms, I will try my best to summary it and post articles in my blog. May 9th1. leetcode 58: Length of Last Word link: https://leetcode.com/problems/length-of-last-word/ submission: https://github.com/FuyaoLi2017/leetcode/blob/master/String/leetcode_058_LengthofLastWord.java 2. leetcode 59: Spiral Matrix II link: https://leetcode.com/problems/spiral-matrix-ii/ submission: https://github.com/FuyaoLi2017/leetcode/blob/master/Array/leetcode_059_SpiralMatrixII.java 3. leetcode 61: Rotate List link: https://leetcode.com/problems/rotate-list/ submission: https://github.com/FuyaoLi2017/leetcode/blob/master/LinkedList/leetcode_061_RotateList.java 3. leetcode 63: Unique Paths II link: https://leetcode.com/problems/unique-paths-ii/ submission: https://github.com/FuyaoLi2017/leetcode/blob/master/DP/leetcode_063_UniquePathsII.java May 11th leetcode 975 leetcode 78 leetcode 68]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-4 Building A GraphQL API]]></title>
    <url>%2F2019%2F05%2F01%2Fgraphql-4%2F</url>
    <content type="text"><![CDATA[In this chapter, we discuss the features of a GraphQL API and mechanics behind it. 4.1 GraphQL API mechanicsAll GraphQL APIs offer a number features that we need to understand in order build GraphQL APIs. The heart of this configuration is the GraphQL schema with its type definition. GraphQL Validation: Any request that is received by a GraphQL API, is first syntactically validated against the GraphQL SCHEMA. GraphQL Execution: After the request has been validated, it needs to be interpreted and execute by the server to create a response. Execution of queries: The graphQL SERVER returns a result that structurally mirrors the shape of the requested query. Before sending to the client, the server serializes the result, typically in JSON format. Creating a response to a query is actually a traversal of the graph. Resolver functions: the resolver function is called recursively. For each of the subgraphs produced as output. A subgraph is an instance of a certain type. When such a subgraph is processed, the resolver function of its corresponding type is called. If the resolver function for a certain subgraph produces a scalar value like a string or number, the recursion terminates in that branch. The resolver function receive three arguments. obj: the parent object of the fields being resolved(graphQL query/mutation/subscription).(often null or left out). args: the arguements provided to the fields in the graphQL query/mutation/subscription. context: holds important contextual information, such as authenticated user and access to a database. Execution of subscription: There is no confirmation response. A response is only generated when the event actually occurs. The best practice to realize this bidirectional communication via teh webSocket protocol. 4.2 GraphQL server architecture4.2.1 Green Field case: without involving any existing legacy systemsThere can be multiple API endpoints lying above business logic.RPC APIs, REST APIs, GraphQL APIs =&gt; Business logic =&gt; DB 4.2.2 Legacy caseCases we need to deal with existing legacy services and databases. 4.3 GraphQL API design methodology4.3.1 API Design Approach4.3.1.1 Consumer-Oriented APIThe consumers of an API are the various developers building clients with the API. We need to know our prototypical API consumers, their needs, and the architecture of the solutions they are building. 4.3.1.2 ReusabilityConsumer-oriented design can sometimes lead into trap of basically designing an API for one customer only. Instead, APIs need to be reusable products that can be reused by various consumers and in various use cases. 4.3.1.3 API Product DesignThe basic process for GraphQL API design in no different than the basic process for API design of REST APIs. If we design APIs as reusable products and design them from the perspective of the prototypical API consumers, then we are on the way to build consumer-oriented APIs - APIs that our consumers will love. 4.3.2 GraphQL API Design Phases Each phase of this approach consists of a creative part and a verification part. In each phase of the design and development journey, feedback from the consumers is elicited. It is important to collect the feedback as early as possible. This design approach is meant to be used iteratively. Keep in mind, that in an iterative and agile approach, not all information and requirements about the constructed artifact need to be available in the beginning, but new and more detailed information and insights are gathered and integrated during each iteration. This means we need to start from the needs of the API consumer towards the existing legacy systems, And not the other way! Our proposed API design approach is organized in six phases. 4.3.2.1 Phase 1: Domain AnalysisDomain analysis should get us thinking from an API consumer perspective: Who are the consumers of the API? How does an API consumer prefer to interact with the data delivered by the API? 4.3.2.2 Phase 2: Architectural DesignIn the architecture design phase, we choose a server architecture(4.2), an API philosophy, and an architectural style for realizing the API. In the scope this graphQL design book, we will assume we choose a three-level server architecture with GraphQL as our API philosophy in the front-facing layer. 4.3.2.3 Phase 3: PrototypingFor prototyping a GraphQL API we need to define a schema(see chapter 2), which contains all the relevant types in the type graph. We use automatically created mock data, to simulate the response of the API and some first feedback and the API design. In this phase we can iterate multiple times by extending the schema and collecting feedback based on the mocked API. 4.3.2.4 Phase 4: Implementing for ProductionWhen implementing for production, we gradually move away from the use of mocked data, towards real data and real backend systems. At this point, the accidental complexity of the organically grown legacy systems may hit us and the API developers. In this phase, non-functional properties come into focus, such as stability, performance, and security. 4.3.2.5 Phase 5: PublishingAs soon as the GraphQL API is published, it needs to stay backward compatible with the original published version. Knowing about this hard cut imposed with initial publication of the GraphQL API, we need to ask if we have tested enough and have received enough and have received enough consumer feedback to be confident to take the big leap of publishing the API. 4.3.2.6 MaintenanceDuring the maintenance, bugs and issues may be resolved, but also new functionality maybe introduced, as long as it is backward compatible: functionality and fields may be added without breaking clients, removing functionality or fields is not permitted.Further down the line, we want to learn whether and why consumers use the API. We need to observe the metrics of our API to learn how consumers use the API. This cannot be based on analytics alone, but we need to communicate with our API consumers one-on-one and build and active community.]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-3 GraphQL query language]]></title>
    <url>%2F2019%2F04%2F19%2Fgraphql-3%2F</url>
    <content type="text"><![CDATA[3.1 PatternsGraphQL queries consist of one or more patterns which are matched agianst the big graph containing all the data on the server. A pattern is expressed in terms of the relationships between objects and the fields the objects contain. Multi-level hierarchies can be built because a field can also be an object which contains its own fields. 3.2 GraphQL methods query is used for retrieval, for reading data(see 3.3) mutation is used for modification, for writing data (see 3.4) subscription is used for notification of changed data (see 3.5) 3.3 GraphQL QueryTo read data with graphQL, the client uses the query method. In the pattern of this query, the client has to explicitly specify all the object and fields it is interested in. 12345query &#123; books &#123; title &#125;&#125; Executing the query might result in the following data, which is returned in JSON format. For graphQL, query and response have the same shape. The query is comparable to a template in a template language. Just like functions in JS, queries can be anonymous or named. If a query is given a name, it allows us identify it easier later on.12345query myBookQuery &#123; books &#123; title &#125;&#125; 3.3.1 Objects Inside the query method, one or more objects can be retrieved. An object can not be retrieved without explicitly specifying the fields that should be returned. 3.3.2 Fields Objects have fields of their own, primitives do not. The types of the fields are objects, array or a primitive type. The query language does not ditinguish between lists and single elements, such as primitives or objects. If the fields is a list, its fields are actually the fields of each element in the list. 12345query &#123; books &#123; title &#125;&#125; If field has further fields itself, we can create a new level of nesting. The result tree gets deeper. 12345678query &#123; books &#123; title author [ name ] &#125;&#125; 3.3.3 Arguments An argument is used to put constraints on objects. Only objects which satisfy the constraints imposed by the argument are included in the result. An argument in GraphQL is comparable to a WHERE in SQL. In graphQL, the arguments are identified and passed in by their name.(id in our example) 3.3.4 Alias To avoid name confilct, we cna rename a fields with an alias.12345678query &#123; book_by_id (id:&quot;1234&quot;) &#123; title &#125; second_book: book_by_id (id:&quot;5678&quot;) &#123; title &#125;&#125; 3.3.5 Fragments Some queries contain repeating elements. In this case, it is tedious to get consistent in the first palce and tedious to maintain consistency. Repeating elements of a query can be factored out into socalled fragments. Fragments need to be defined once (using fragment keyword) and can be applied mulitple times (using the … keyword) ExampleWe can rewrite the previous example with the following code sample. 123456789101112131415query &#123; book_by_id (id:&quot;1234&quot;) &#123; ...bookinfo &#125; second_book: book_by_id (id:&quot;5678&quot;) &#123; ...bookinfo &#125;&#125;fragment bookinfo on Book &#123; title author &#123; name &#125;&#125; Note, that a fragment is defined for a specific type. (see section 2.3),in our example, the fragment is specific for a Book. 3.3.6 Inline Fragments Inline fragment are used to distinguish different types. It is similar to an instanceof operator in OOP languages. Inline fragments are for ploymorphism, i.e. for interface and union types. With inline fragments, we can check the type of an object at runtime. Example of using inline fragment in interface To access the private-owned fields of implementation type of interfaces. We need to use inline fragments. We first define an interface and two implementation types. 1234567891011121314151617interface Document &#123; title: String, text: String, authors: [Author]&#125;type Book implements Document &#123; id: ID!&#125;type Article implements Document &#123; magazine: String!&#125;type Query &#123; readingList: [Document]&#125; If we want to access the id field for Book or magazine field for article, we need to specify which type it really belongs to, we need to use inline fragment in this case. The query format should be as follows. 123456789101112131415query &#123; readingList &#123; title text authors&#123; name &#125; ... on Book &#123; id &#125; ... on Article &#123; magazine &#125; &#125;&#125; For interfaces, we use use inline fragments to access additional fields. For union types, since a union in general share no fields. Inline fragment have to be used for accessing any fields in a union. 3.3.7 Variables Variables can be used to pass different values into a query. When this value needs to be changed, the query itself can stay as it is. Format {$variable name}: {type of the bookID}[!,nothing(means whether this is a required parameter)] [= default value] 12345query getSpecificBook ($BookID: String = &quot;1234&quot;) &#123; book_by_id (id: $bookID) &#123; title &#125;&#125; Variable need to have a type (primitive or object type) 3.3.8 Directives Directives can be used to dynamically include or exclude a part of a query. Dynamically means depending on the value of boolean variable. This boolean variable has to be decleared just like any other variables. There are two types of directives: one to include (@include keyword) a part of the query and one to exclude (@skip keywords) a part of the query.123456query getBooks($flag: boolean) &#123; books&#123; title id @include(if: $flag) &#125;&#125; The above examples includes the id fields only if the value $flag is true. 123456query getBooks($flag: boolean) &#123; books&#123; title id @skip(if: $flag) &#125;&#125; The above example is the reverse meaning for the first example. 3.4 GraphQL mutations The mutation method is used for modifying, adding or writing data on the server with GraphQL.123456mutation &#123; addBook (title: &quot;New Book&quot;) &#123; id title &#125;&#125; 3.5 GraphQL Subscirption Modern clients need to get near real-time updates that get triggered when something changes on the server. REST does not provide any built-in support for such notifications from the server; thus notifications are often realized by polling or by webhooks. You can refer more details about webhooks in the below resources. Book, Webhooks - Events for REST APIs https://sendgrid.com/blog/whats-webhook/ With polling, the client periodically sends requests to the server. The client usually needs to poll on an endpoint that returns a list of elements and compares the retrieved list against the previously retrieved list in order to find the new elements.(expensive operation) With webhooks, the server calls the client, whenever the resources becomes available. To set this up, the client first needs to register an endpoint that gets called by the server. The client needs to be able to expose this endpoint that can receive the events. GraphQL implementation GraphQL offers subscriptions as a built-in mechanism for realizing notifications. First step: client need to send a subscription request to the graphQL API. The request specfies both the event to observe and the data. 123456subscription &#123; bookAdded &#123; id title &#125;&#125; When to trigger? In most cases, notification is triggered by a modification of the data inside the graph, i.e. mutation. This means an event handler needs to be installed inside the implementation of the mutation. In rare cases, notifcation can be triggered by an external event, which is direclty accessible inside the graph or only accessible in aggregated form. An example is sensor data, of which a single measurement may be used as a trigger, whereas the graph only contains aggredated sensor data and no single measurements. I still have some questions regarding how to implement the Subscriptions with GraphQL! Remaining to be explored!]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-2 GraphQL Schema Language]]></title>
    <url>%2F2019%2F04%2F14%2Fgraphql-2%2F</url>
    <content type="text"><![CDATA[GraphQL Type SystemGraphQL have strong type systems. A field can be amrked with an exclamation mark ! to indicate that the field is obligatory (will not be null). Otherwise, it will be nillable (optional fields). During execution/resolutoin of a query, the type system helps to determine what to do next. When crafting queries, the introspection mechanism provided through the type system, allows us to do syntax directly editing and guide us with respect to what is possible and available. Root typesRoot types can be used as the starting point for a certain operation. Query Mutation SubscriptionNoticeEvery graphQL implementation must ahve define a query and a mutation and subscription can be optional. 12345678910111213type Query &#123; books: [Book] book(title:String!): Book book_by_id(id:ID!):Book&#125;type Mutation &#123; addBook(title: String!): Book&#125;type Subscription &#123; bookAdded: Book&#125; Scalar Typesbuilt-in GraphQL scalar types int float boolean String ID (used uniquely identify an object) Custom scalar types Isbn (example) [Author] (square brackets represent a list of things) Array representation Used to express a list of objects [int] [Book] EnumAn enum has a limited set of values it can possibly to take on.12345enum trafficLight &#123; RED GREEN YELLOW&#125; Interface An interface is similar to a type definition, it defines a list of fields, but it can’t be instantiated. 12345interface Document &#123; title: String text: String authors: [Author]&#125; A regular type that implements the interface can extend the interface. 123type Book implements Document &#123; id: ID!&#125; The implementing type automatically contains the fields defined in the interface, they don’t need to be mentioned explicitly. To access the additional fields of a type implementing an interface in a query, we always need to make a distinction by type using inline fragments.(refer to section3.3.6) Union A Union is a common type for serveral defining types. If an object is of a union type, it could be any of it s defining types.1union Product = Book | Software | Bread Differences between Union and interfaces interface is to express common fields union don’t need to have fields in common To access the fields of a union type, we need to make a distinction by type using in the inline fragments.(section3.3.6) Input TypesInput types are used for passing input data in the form of arguments. Input types are used in mutations. When an instance of an input type is serialized, the data is formatted in JSON syntax. It looks like the definition of regular object types, but with keyword input instead of type. !!!! Input types can’t have fields of an object type, only scalar types, list types, and other input types. To prevent mixing, it is a useful convention, to amrk input types, e.g. by using the postfix Input.123456789input BookInput &#123; title: String authors: [AuthorInput]&#125;input AuthorInput &#123; name: String books: [BookInput]&#125;]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline comment in Github PR]]></title>
    <url>%2F2019%2F04%2F07%2Finline-comment-in-Github-PR%2F</url>
    <content type="text"><![CDATA[Github Feature： inline comment in Github PR I didn’t notice this before and I think this is a very good feature. It could give suggestions regarding specific lines. The suggestioned lines can be commited directly. It is very convenient to use. Refer to this link for more detailed GIF.]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-1 GraphQL Introduction]]></title>
    <url>%2F2019%2F04%2F03%2Fgraphql-1%2F</url>
    <content type="text"><![CDATA[This series of articles are summarized from “GraphQL API design” 1.1 Interaction between frontend and backendThese needs of frontends regarding the interaction with backends are quite universal. Thus, a couple of philosophies, such as RPC, SOAP, REST, and GraphQL, have been developed to structure the interaction between frontend and backend. What is GraphQL?GraphQL allows us to build APIs for retrieving data, writing data and getting notified when data changes. GraphQL offers: a declarative, typed query language for APIs a schema language for specifying data structures a runtime for building APIs Why are there two languages in GraphQL?1. Query languageThe purpose of the query language is to interact with the GraphQL endpoint. 2. schema definition languageTo define the structure of the business data exposed by the GraphQL API. API providers use the schema definition language to specify the interface. What the graph in GraphQL?A graph is a very generic data structure, it should be possible to express the data of any application in the form of a graph. And this graph, formed by all application data, is what we call the graph in GraphQL. All data is exposed via a single endpoint in GraphQL. Compared with REST endpoints, the single GraphQL endpoint expose a lot of data. This comprehensive set of data with its entities and relationships between the various entities forms the graph of GraphQL. REST APIs exposes data not in a format of generic type. Both REST and GraphQL are capable of expressing application data in form of a graph, with GraphQL the graph is more explicit, since it is served on a single endpoint. A GraphQL application GraphQL API: part of the backend GraphQL client: part of the frontend]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>ardent academy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deployment workflow]]></title>
    <url>%2F2019%2F04%2F01%2FSecure-Deployment-of-Projects%2F</url>
    <content type="text"><![CDATA[Intuition of writing this BlogAs an intern in ardent academy, I must know how to deploy projects in a secure and reliable manner. We work on Agile development environment. There are something I need to pay attention to when I want to submit a PR to the working repo. Starting a task Go to the “Active Sprints” section of your project and find an Issue. Change the status from “To Do” to “IN PROGRESS” and start your development. Completing a task Once tbe development is done and create a pull request (PR) and commit your code, follow the conventional commits and git flow. We rely on a Continuous Integration and Delivery system (CI/CD) called Drone. Drone runs unit tests then deploys our applications to their staging and production environments. Visit our Drone dashboard at drone.ardentlabs.io to see the progress of your build. Unit testing Run Prettier to format your code: npm run prettier Commit the changes to a new branch. Each branch should contain one functional change, accompanied with tests and/or migration scripts. The smaller the change, the faster it takes for others to review. Feature: feat/office-location Refactor: refactor/rename-classroom Fix: fix/lesson-ordering Hotfixes (Urgent fixes to master) Fork hotfix branch from master (hotfix/everything-is-on-fire) Implement your hotfix - be sure to run Prettier and follow Conventional Commits Push your branch to GitHub Create two PRs, one merging into master and one merging into develop Request reviews from reviewers then make any requested changes The two PRs should be reviewed in tandem. Once they pass reviews, merge both PRs. How to do release git checkout master git pull git checkout develop git pull git merge master npm run release git push –follow-tags git checkout master git merge develop git push]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>deployment</tag>
        <tag>ardent academy</tag>
        <tag>web developments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to build a Blog based on Hexo]]></title>
    <url>%2F2019%2F03%2F25%2Fbuild-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[1. My blogGenerally, I build this blog with hexo and github pages. Then, I bought a domain name and attached the github page to that domain name. This is the blog I am using right now. You can refer to the source code at this link: https://github.com/FuyaoLi2017/FuyaoLi2017.github.io, you are welcomed to fork and leave me comments~ 2. Github page and domain name settings create a github account and create a repo with exactly the name [yourusername].github.io, in the Settings tab, configure your customized domain name. Remember to create the SSH key for your local computer to upload the code to Github. I bought my domain name on Godaddy.com and configured the DNS settings following this link: https://medium.com/@coryminglee/hosting-your-github-page-in-godaddy-domain-in-2018-b872b39190f9. If you want to enable a more secure connection, you might want to buy a certificate to enable HTTPS. I think it is kind of expensive for me, so I just choose to leave it as HTTP connection. 3. Blog configuration I used Hexo to build my blog and choose the next theme to be my current theme. It allows me to update the and deploy my blog automatically. Refer to this link to generate a hexo project folder:https://hexo.io/ Most configurations are made in _config.yml(general configuration) and themes/next/_config.yml(customized configuration for your own theme) 3.1 _config.yml configuration You can follow the existing hints in the _config.yml to do basic configurations.deploymentFor the deployment, which is the most important thing, you need to configure it as follows. Remember to leave a space after type:, this is super important for all configuration, the content won’t be parsed if you don’t put a space here.1234deploy: type: git repo: https://github.com/FuyaoLi2017/FuyaoLi2017.github.io.git branch: master Search function12345search: path: search.xml field: post format: html limit: 10000 Sitemap123# Site mapsitemap: path: sitemap.xml Theme configurations12## Themes: https://hexo.io/themes/theme: next RSSfollow this link to configure you RSS: https://github.com/hexojs/hexo-generator-feed.I just found that in chrome, it will just bring up the source code, which is super weird, so I disabled this function. 3.2 themes/next/_config.yml configurationfaviconThe images the relative path starts from the source folder in the themes/next, if you put a photo in the themes/next/source/images, you can configure like this.123456789101112favicon: #small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png #apple_touch_icon: /images/apple-touch-icon-next.png #safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml small: /images/photo.jpeg medium: /images/photo.jpeg apple_touch_icon: /images/photo.jpeg safari_pinned_tab: /images/photo.jpeg menu You can define the project folders you want to show. If you want to create more menu items. You can use hexo new page [something], refer to this link to find more detailed instructions:https://hexo.io/docs/writing.html. For the menu icons, you need to find the corresponding representation in the link https://fontawesome.com/icons?d=gallery and configure it after the parallel just like this.1234567891011121314menu: home: / || home about Fuyao: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive Projects: /projects/ || tasks #schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true Schemesconfigure the scheme you like and uncomment it like the code script below. Examples of different schemes can be found here:https://github.com/iissnan/hexo-theme-next. Check it and find one you like better.12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini FontsFonts can be configured in the fonts tags and it can be configured in five aspects. You can check out fonts in fonts.googleapis.com and put the name of the fonts here to update your blog’s fonts.123456789101112131415161718192021222324252627282930313233343536373839404142font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Merriweather size: 14 # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: Merriweather size: 20 # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: Merriweather # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: Lemon size: 26 # Font settings for &lt;code&gt; and code blocks. codes: external: true family: PT Mono size: Comment functionThere are multiple ways to realize the comment function. Disqus is a easy way to implement that, register a disqus account and configure it as follows should add comment function to your blog.12345# Disqusdisqus: enable: true shortname: [short name for your disqus account] count: true Vistor count functionThere are multiple ways to enable this function. I used leancloud to realized that. You can register an account in leancloud and create a empty database called Counter. Then, just copy the app_id and app_key here to realize that.1234leancloud_visitors: enable: true app_id: [your app id] app_key: [your app key] More advanced options background pictures can be configured in themes/next/source/css/_custom/custom.styl. My configuration works on PC side, the mobile side is not working so well, you can make more complicated cofiguration to make it adaptable. 12345678910body &#123;background-image:url(/images/golden-gate-bridge.jpg);background-repeat: no-repeat;background-size: cover;background-attachment:fixed;&#125;#footer a &#123; color:#eee;&#125; The width of the blog area is kind of too small. I configured it to be larger with relative parameter settings. After consulting so many blogs. I found the following configuration is the most simple and powerful choice. In themes/next/source/css/_variables/custom.styl, you need to configure it as follows using the calc function in CSS. 12$main-desktop = 75%$content-desktop = calc(100% - 252px) 4. EndThanks for reading my blog. Hope it can help you with buliding you own blog! You are welcome to leave comments if you have any problems.]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
